`timescale 1ns / 1ps
`default_nettype none
//`define DBG

module Registers #(
    parameter ADDR_WIDTH = 5,
    parameter WIDTH = 32
)(
    input wire clk,
    input wire [ADDR_WIDTH-1:0] rs1,
    input wire [ADDR_WIDTH-1:0] rs2,
    input wire [ADDR_WIDTH-1:0] rd,
    input wire [WIDTH-1:0] rd_wd, // data to write to register 'rd' when 'rd_we' is enabled
    input wire rd_we,
    output wire [WIDTH-1:0] rd1, // value of register 'ra1'
    output wire [WIDTH-1:0] rd2, // value of register 'ra2'
    input wire [ADDR_WIDTH-1:0] ra3, // register address 3
    input wire [WIDTH-1:0] wd3, // data to write to register 'ra3' when 'we3' is enabled
    input wire we3
);

reg signed [WIDTH-1:0] mem [0:2**ADDR_WIDTH-1];

assign rd1 = rs1 == 0 ? 0 : mem[rs1];
assign rd2 = rs2 == 0 ? 0 : mem[rs2];

integer i;
initial begin
    for (i = 0; i < 2**ADDR_WIDTH; i = i + 1) begin
        mem[i] = {WIDTH{1'b0}};
    end
end

always @(posedge clk) begin
    `ifdef DBG
        $display("%0t: clk+: Registers (ra3,we3)=(%0h,%0h)", $time, ra3, we3);
    `endif

    // only write 'wd3' to 'ra3' if the register is not used in an op 
    if (we3 && ra3 != 0 && !(rd_we && ra3 == rd))
        mem[ra3] <= wd3;
end

always @(posedge clk) begin
    `ifdef DBG
        $display("%0t: clk+: Registers (rs1,rs2,rd)=(%0h,%0h,%0h)", $time, rs1, rs2, rd);
    `endif

    if (rd_we && rd !=0)
        mem[rd] <= rd_wd;
end

endmodule

`undef DBG
`default_nettype wire